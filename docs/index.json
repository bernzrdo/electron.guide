[{"body":" BrowserWindow Windows    Windows 10 Windows 7              macOS   ","excerpt":" BrowserWindow Windows    Windows 10 Windows 7              macOS   ","ref":"https://electron.guide/cross-platform/browser-window/","title":"BrowserWindow"},{"body":" Context Menu Windows    Windows 10 Windows 7              macOS   ","excerpt":" Context Menu Windows    Windows 10 Windows 7              macOS   ","ref":"https://electron.guide/cross-platform/context-menu/","title":"Context Menu"},{"body":" Menu Windows A Windows applications typically contain a menu bar at the top of the individual window.\n   Windows 10 Windows 7              macOS macOS uses a common menu bar at the screen’s top that the operating system and all applications share. When a particular window gets focus, the menu contents change based on the menu required by the window.\n  ","excerpt":"Menu Windows A Windows applications typically contain a menu bar at the top of the individual window.\n   Windows 10 Windows 7              macOS macOS uses a common menu bar at the screen’s top that the operating system and all applications share. When a particular window gets focus, the menu contents change based on the menu required by the window.","ref":"https://electron.guide/cross-platform/menu/","title":"Menu"},{"body":" Notifications Windows    Windows 10 Windows 7       Basic      Basic        Notification with image      Notification with image       macOS    Basic Notification with image              Extra Info  https://electronjs.org/docs/tutorial/notifications (HTML5 Renderer Process) https://github.com/mikaelbr/node-notifier (A more powerful cross-platform option) https://github.com/felixrieseberg/electron-windows-notifications  ","excerpt":"Notifications Windows    Windows 10 Windows 7       Basic      Basic        Notification with image      Notification with image       macOS    Basic Notification with image              Extra Info  https://electronjs.","ref":"https://electron.guide/cross-platform/notifications/","title":"Notifications"},{"body":" Standard Dialogs Windows    Windows 10 Windows 7       Open file      Open file        Save file      Save file       macOS    Open Save              ","excerpt":" Standard Dialogs Windows    Windows 10 Windows 7       Open file      Open file        Save file      Save file       macOS    Open Save              ","ref":"https://electron.guide/cross-platform/standard-dialogs/","title":"Standard Dialogs"},{"body":" The Final Polish before release Prevent a second instance of your application from running Usually, you only want one instance of your application running at any moment.\nconst { app } = require(\u0026#39;electron\u0026#39;) const gotTheLock = app.requestSingleInstanceLock() if (!gotTheLock) { app.exit(0) }  See: https://electronjs.org/docs/api/app#apprequestsingleinstancelock\nStore configuration data Users expect any customizations to their settings to persist on app reload (e.g. computer restart).\nYou can use electron-store to save data.\nFor sensitive security data such as OAuth tokens, you MUST store them in the \u0026ldquo;password vault\u0026rdquo; provided by the operating system.\nYou can use node-keytar for this.\nAn excellent blog post with instructions is here.\nUsing Keytar requires the library to be \u0026ldquo;rebuilt\u0026rdquo; for each OS/Electron version you want to deploy to:\n https://github.com/electron/electron-rebuild https://github.com/electron/electron/blob/master/docs/tutorial/using-native-node-modules.md  Catch Fatal Exceptions Sometimes Electron Applications mysteriously crash. Other times, they display a hideous error message:\n  You can intercept it and replace the error message with a prettier window:\nprocess.on(\u0026#39;uncaughtException\u0026#39;, error =\u0026gt; { // Replace code below to display a prettier window \tconsole.error(\u0026#39;Exception:\u0026#39;, error); app.exit(1); });  An additional suggestion is you can use the package clean-stack to filter the noise in the stack trace and then transmit the error data to your server before exiting.\n See https://github.com/sindresorhus/electron-unhandled. See https://electron.guide/electron-alert/#exception-alert (recommended) See https://electronjs.org/docs/api/crash-reporter  ","excerpt":"The Final Polish before release Prevent a second instance of your application from running Usually, you only want one instance of your application running at any moment.\nconst { app } = require(\u0026#39;electron\u0026#39;) const gotTheLock = app.requestSingleInstanceLock() if (!gotTheLock) { app.exit(0) }  See: https://electronjs.org/docs/api/app#apprequestsingleinstancelock\nStore configuration data Users expect any customizations to their settings to persist on app reload (e.g. computer restart).\nYou can use electron-store to save data.","ref":"https://electron.guide/final-polish/application/","title":"The Final Polish - Application"},{"body":" The Final Polish before release The BrowserWindow is actually a chromium web browser!\nPassing data into BrowserWindow If you use React.js for your BrowserWindow javascript, you may need to pass data from the main process to the renderer process just in time for your initial state and props.\nYou need to know the difference between these two events: dom-ready and ready-to-show.\n ready-to-show event is part of BrowserWindow, and dom-ready event is part of webContents. In the BrowserWindow event life-cycle, dom-ready always comes BEFORE ready-to-show. You can inject data like this:  // main.js (main process)  const { BrowserWindow } = require(\u0026#39;electron\u0026#39;) let win = new BrowserWindow({ show: false }) win.once(\u0026#39;ready-to-show\u0026#39;, () =\u0026gt; { win.show() }) win.webContents.on(\u0026#39;dom-ready\u0026#39;, (event) =\u0026gt; { win.webContents.send(\u0026#34;\u0026lt;channel\u0026gt;\u0026#34;, Data1, Data2, Data3) // This is asynchronous }) // renderer.js (renderer process)  const { ipcRenderer } = require(\u0026#39;electron\u0026#39;) ipcRenderer.once(\u0026#34;\u0026lt;channel\u0026gt;\u0026#34;, (event, args) =\u0026gt; { let Data1 = args[0] })  See:\n https://electronjs.org/docs/api/browser-window https://electronjs.org/docs/api/web-contents  Fade in BrowserWindow The above advice will abrupty show the BrowserWindow without any flickering. If you are using React.js, then it is possible that your page has not yet completed rendering. If you want to guarantee that your page has finished rendering, then only show it after rendering is complete.\nYou can further smoothen your application by creating a fade-in effect to make it feel less abrupt.\nA linear fade-in animation curve can be easily accomplished. totalTime (ms) controls how long the fade-in effect should take in total (transparent → opaque). totalSteps controls the time-resolution.\n// main.js (main process)  const { BrowserWindow, ipcMain} = require(\u0026#39;electron\u0026#39;) let win = new BrowserWindow({ show: false, opacity: 0.0 }) // initially transparent  win.webContents.on(\u0026#39;dom-ready\u0026#39;, (event) =\u0026gt; { win.webContents.send(\u0026#34;\u0026lt;channel\u0026gt;\u0026#34;, Data1) // This is asynchronous }) ipcMain.once(\u0026#34;browser-window-ready-to-show\u0026#34;, (event, args) =\u0026gt; { win.show() }) // renderer.js (renderer process)  const { ipcRenderer, remote } = require(\u0026#39;electron\u0026#39;) ipcRenderer.once(\u0026#34;\u0026lt;channel\u0026gt;\u0026#34;, (event, args) =\u0026gt; { let Data1 = args[0] ipcRenderer.send(\u0026#34;browser-window-ready-to-show\u0026#34;) let currentWindow = remote.getCurrentWindow() let totalSteps = 20.0 let totalTime = 1000.0 let currentOpacity = currentWindow.getOpacity() let timerID = setInterval(() =\u0026gt; { currentOpacity = currentOpacity + (1.0/totalSteps) currentWindow.setOpacity(currentOpacity) if currentOpacity \u0026gt; 1.0 { clearInterval(timerID); } }, totalTime/totalSteps) })  If your BrowserWindow is set to transparent, you can also use a CSS based solution for fading-in.\nPrevent BrowserWindow refreshes A user can press Cmd+R (on macOS) or Ctrl+R/Ctrl+Shift+R/F5 (on Windows) to refresh the webpage shown by the BrowserWindow. True native applications don\u0026rsquo;t exhibit this behaviour.\nThe recommended solution is to replace the default menu to disable this behaviour. On Windows, you can call win.removeMenu(). On macOS, you can call Menu.setApplicationMenu(Menu.buildFromTemplate([])). You should only do it for production since you will lose access to DevTools.\nFor Kiosk Mode, another solution is to Disable the keyboard shortcuts when the BrowserWindow takes focus and then unregister the shortcuts when the BrowserWindow loses focus or is closed/hidden.\nconst { globalShortcut } = require(\u0026#39;electron\u0026#39;) win.on(\u0026#39;focus\u0026#39;, (event) =\u0026gt; { globalShortcut.registerAll([\u0026#39;CommandOrControl+R\u0026#39;,\u0026#39;F5\u0026#39;], () =\u0026gt; {}) }) win.on(\u0026#39;blur\u0026#39;, (event) =\u0026gt; { globalShortcut.unregisterAll() })  See: https://electronjs.org/docs/api/global-shortcut\nPrevent File Drags into BrowserWindow A user can drag a file into a BrowserWindow. The BrowserWindow will then display the file. You can disable it by using https://github.com/ecrmnn/electron-disable-file-drop.\nrequire(\u0026#39;electron-disable-file-drop\u0026#39;); // In renderer process  Disable Dragging and User Selections Users can drag certain elements inside the Body. They can also \u0026ldquo;select\u0026rdquo; content on the window (to cut/copy). True native applications don\u0026rsquo;t exhibit this behavior.\nAdd this CSS:\n.noselect { user-select: none; } Add this attribute and class to the Body and various HTML elements:\n\u0026lt;body draggable=\u0026#34;false\u0026#34; class=\u0026#34;noselect\u0026#34;\u0026gt; Hide DevTools The user can easily open up the BrowserWindow DevTools and peek inside and modify your variables. This is very dangerous from a security perspective.\nThe user can open the DevTools by keyboard shortcuts and passing command line arguments.\nRemember to disable it for Production release:\nconst { BrowserWindow } = require(\u0026#39;electron\u0026#39;) let win = new BrowserWindow({ webPreferences: {devTools: false} })  See: https://github.com/electron/electron/blob/master/docs/api/browser-window.md#new-browserwindowoptions\nYou may have to take other measures too to hide DevTools successfully.\n","excerpt":"The Final Polish before release The BrowserWindow is actually a chromium web browser!\nPassing data into BrowserWindow If you use React.js for your BrowserWindow javascript, you may need to pass data from the main process to the renderer process just in time for your initial state and props.\nYou need to know the difference between these two events: dom-ready and ready-to-show.\n ready-to-show event is part of BrowserWindow, and dom-ready event is part of webContents.","ref":"https://electron.guide/final-polish/renderer/","title":"The Final Polish - BrowserWindow"},{"body":" Tray Windows    Windows 10 Windows 7               Tray menu      Tray menu        Balloon      Balloon       macOS   ","excerpt":" Tray Windows    Windows 10 Windows 7               Tray menu      Tray menu        Balloon      Balloon       macOS   ","ref":"https://electron.guide/cross-platform/tray/","title":"Tray"}]